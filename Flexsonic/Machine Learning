//To read values

#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/adc.h"
#include "driver/i2c.h"
#include "esp_log.h"
#include "mpu6050.h"  // You'll need an MPU6050 library

#define FLEX1_CHANNEL ADC1_CHANNEL_0 // GPIO36
#define FLEX2_CHANNEL ADC1_CHANNEL_3 // GPIO39
#define FLEX3_CHANNEL ADC1_CHANNEL_6 // GPIO34
#define FLEX4_CHANNEL ADC1_CHANNEL_7 // GPIO35
#define FLEX5_CHANNEL ADC1_CHANNEL_4 // GPIO32

void app_main(void) {
    // Initialize ADC for flex sensors
    adc1_config_width(ADC_WIDTH_BIT_12);
    adc1_config_channel_atten(FLEX1_CHANNEL, ADC_ATTEN_DB_11);
    adc1_config_channel_atten(FLEX2_CHANNEL, ADC_ATTEN_DB_11);
    adc1_config_channel_atten(FLEX3_CHANNEL, ADC_ATTEN_DB_11);
    adc1_config_channel_atten(FLEX4_CHANNEL, ADC_ATTEN_DB_11);
    adc1_config_channel_atten(FLEX5_CHANNEL, ADC_ATTEN_DB_11);

    // Initialize I2C and MPU6050 here (library dependent)
    mpu6050_init();

    while(1) {
        int flex1 = adc1_get_raw(FLEX1_CHANNEL);
        int flex2 = adc1_get_raw(FLEX2_CHANNEL);
        int flex3 = adc1_get_raw(FLEX3_CHANNEL);
        int flex4 = adc1_get_raw(FLEX4_CHANNEL);
        int flex5 = adc1_get_raw(FLEX5_CHANNEL);

        float pitch, roll, yaw;
        mpu6050_read_angles(&pitch, &roll, &yaw);

        // Normalize flex sensors (0-4095 to 0-1)
        float norm_flex1 = flex1 / 4095.0f;
        float norm_flex2 = flex2 / 4095.0f;
        float norm_flex3 = flex3 / 4095.0f;
        float norm_flex4 = flex4 / 4095.0f;
        float norm_flex5 = flex5 / 4095.0f;

        // Print CSV line
        printf("%.3f,%.3f,%.3f,%.3f,%.3f,%.2f,%.2f,%.2f\n",
            norm_flex1, norm_flex2, norm_flex3, norm_flex4, norm_flex5,
            pitch, roll, yaw);

        vTaskDelay(pdMS_TO_TICKS(100));  // 10 Hz sampling
    }
}

//Python script

import serial
import csv
import time

# Set your serial port and baud rate
SERIAL_PORT = 'COM3'  # Windows example, on Linux/Mac might be '/dev/ttyUSB0'
BAUD_RATE = 115200

def main():
    # Open serial connection
    ser = serial.Serial(SERIAL_PORT, BAUD_RATE)
    print("Connected to ESP32 on", SERIAL_PORT)

    gesture_label = input("Enter the gesture name you want to record: ").strip()
    filename = f"{gesture_label}_{int(time.time())}.csv"

    with open(filename, mode='w', newline='') as csvfile:
        csv_writer = csv.writer(csvfile)
        # Write header row
        csv_writer.writerow(['flex1', 'flex2', 'flex3', 'flex4', 'flex5', 'pitch', 'roll', 'yaw', 'label'])

        print(f"Recording data for gesture: {gesture_label}. Press Ctrl+C to stop.")

        try:
            while True:
                line = ser.readline().decode('utf-8').strip()
                if not line:
                    continue

                # The ESP32 sends 8 comma-separated values
                parts = line.split(',')
                if len(parts) != 8:
                    print("Malformed data:", line)
                    continue

                # Append label and write to CSV
                csv_writer.writerow(parts + [gesture_label])
        except KeyboardInterrupt:
            print("\nData recording stopped.")
        finally:
            ser.close()

if __name__ == "__main__":
    main()

//How to use this:
Connect your ESP32 and make sure it’s sending sensor data over serial.

Change SERIAL_PORT to your actual port name.

Run the Python script: python data_logger.py

When prompted, type the gesture name you’re recording (e.g., “HELLO”).

Perform the gesture repeatedly while script logs data.

Press Ctrl+C when done — CSV file saved with your data.//

